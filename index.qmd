---
title: "Cloud-Optimized Geospatial Formats Guide"
subtitle: "Methods for Generating and Testing Cloud-Optimized Geospatial Formats"
---

## Why Cloud Optimize?

Geospatial data is experiencing exponential growth in both size and complexity. As a result, traditional data access methods, such as file downloads, have become increasingly impractical for achieving scientific objectives. With the limitations of these older methods becoming more apparent, cloud-optimized geospatial formats present a much-needed solution.

Cloud optimization enables efficient, on-the-fly access to geospatial data, offering several advantages:

1. **Reduced Latency**: Data can be fetched and processed much faster compared to downloading entire files.
2. **Scalability**: Cloud-optimized formats are designed to scale, making it easier to work with large datasets.
3. **Flexibility**: Users can access only the necessary data portions, making the process more efficient.
4. **Cost-Effective**: Reduced data transfer and storage needs can lower costs.

If you want to provide optimized access to geospatial data, this guide is designed to help you understand the best practices and tools available for cloud-optimized geospatial formats.

## Built for the community, by the community.

There is no one-size-fits-all approach to cloud-optimized data. Still, the community has developed many tools for creating and assessing geospatial formats that should be organized and shared.

This guide provides the landscape of cloud-optimized geospatial formats and the best-known answers to common questions.

## How to get involved

If you want to contribute or modify content, read the [Get Involved](./contributing.qmd) page.

If you have a question or idea for this guide, please start a [Github Discussion](https://github.com/developmentseed/cloud-optimized-geospatial-formats-guide/discussions/new/choose).

## The opportunity

Putting data in the cloud does not solve the big geospatial data problem. Users cannot reasonably wait to download, store, and work with large files on their machines. Large volumes of data must be available via subsetting methods to access data in memory.

While it is possible to provide subsetting as a service, this requires maintenance of additional servers and network latency (data has to go to the server where the subsetting service is running and then to the user). With cloud-optimized formats and the appropriate libraries, subsets of data can be accessed remotely without introducing an additional server.

Regardless, users will access data over a network, which must be considered when designing the cloud-optimized format. Traditional geospatial formats are optimized for on-disk access via small internal chunks. A network introduces latency, and the number of requests must be considered.

As a community, we have arrived at the following **cloud-optimized format pattern:**

1. Metadata includes addresses for data blocks.
2. Metadata is stored in a consistent format and location.
3. Metadata can be read once.
4. Metadata can read the underlying file format, which supports subsetted access via addressable chunks, internal tiling, or both.

These characteristics allow for parallelized and partial reading.

## Data Type to Traditional to Cloud-Optimized Geospatial File Format Table

The diagram below depicts how some of the cloud-optimized formats discussed in this guide are cloud-optimized formats of traditional geospatial file formats.

![Cloud-Optimized Geospatial Formats](./images/cogeo-formats-table.png)

Notes:

- Some data formats cover multiple data types, specifically:
    - GeoJSON can be used for vector and point cloud data.
    - HDF5 can be used for point cloud data or data cubes (or both via groups).
    - GeoParquet and FlatGeobuf can be used for vector data or point cloud data.
- LAS files are intended for 3D points, not 2D points (since COPC files are compressed LAS files, the same goes for COPC files).
- [TopoJSON](https://github.com/topojson/topojson) (an extension of GeoJSON that encodes topology) and [newline-delimited GeoJSON](https://stevage.github.io/ndgeojson/) are types of GeoJSON worth mentioning but have yet to be explicitly represented in the diagram.
- GeoTIFF and GeoParquet are geospatial versions of the non-geospatial file formats TIFF and Parquet, respectively. FlatGeobuf builds upon the non-geospatial [flatbuffers](https://github.com/google/flatbuffers) serialization library (though flatbuffers is not a standalone file format)

## Table of Contents

1. [Overview of Formats (slideshow)](./overview.qmd)
2. Formats
   a. [Cloud-Optimized GeoTIFFs](./cloud-optimized-geotiffs/intro.ipynb)
   b. [Zarr](./zarr/intro.qmd)
   c. [Kerchunk](./kerchunk/intro.qmd)
   c. [Cloud-Optimized NetCDF4/HDF5](./cloud-optimized-netcdf4-hdf5/index.qmd)
   d. [GeoParquet](./geoparquet/index.qmd)
   e. [FlatGeobuf](./flatgeobuf/intro.qmd)
3. [Cookbooks](./cookbooks/index.qmd)


## Running examples

Most of the data formats covered in this guide have a Jupyter Notebook example that covers the basics of reading and writing the given format. At the top of each notebook is a link to an environment.yml file describing what libraries need to be installed to run correctly. You can use [Conda](https://www.anaconda.com/download) or [Mamba](https://mamba.readthedocs.io/en/latest/index.html) (a successor to Conda with faster package installs) to install the environment needed to run the notebook.

## Authors

* Aimee Barciauskas
* Alex Mandel
* Kyle Barron
* Zac Deziel
* [Overview Slide](./overview.qmd) credits: Vincent Sarago, Chris Holmes, Patrick Quinn, Matt Hanson, Ryan Abernathey

## Questions to ask when generating cloud-optimized geospatial data in any format

1. What variable(s) should be included in the new data format?
2. Will you create copies to optimize for different needs?
3. What is the intended use case or usage profile? Will this product be used for visualization, analysis, or both?
4. What is the expected access method?
5. How much of your data is typically rendered or selected at once?